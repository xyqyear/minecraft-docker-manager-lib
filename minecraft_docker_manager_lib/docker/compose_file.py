import re
from pathlib import Path
from typing import Any, Self

import aiofiles
import yaml
from pydantic import model_validator

from .compose_models import ComposeSpecification, Ports, Volumes


def convert_str_port_to_obj(port: float | str) -> Ports:
    if not isinstance(port, str):
        port = str(int(port))

    # generated by gpt4o. Let's hope it works
    short_syntax_regex = re.compile(
        r"^(?:(?P<host_ip>\d{1,3}(?:\.\d{1,3}){3}):)?"
        r"(?P<host_port>\d+(-\d+)?):(?P<container_port>\d+(-\d+)?)(?:/(?P<protocol>\w+))?$|"
        r"^(?P<container_only_port>\d+(-\d+)?)(?:/(?P<container_only_protocol>\w+))?$"
    )

    match = short_syntax_regex.match(port)
    if match:
        host_ip = match.group("host_ip")
        host_port = match.group("host_port")
        container_port = match.group("container_port")
        protocol = match.group("protocol")

        if container_port is None:
            container_port = match.group("container_only_port")
            protocol = match.group("container_only_protocol")

        return Ports(
            host_ip=host_ip,
            published=host_port,
            target=container_port,
            protocol=protocol,
        )
    else:
        raise ValueError(f"Invalid port format: {port}")


def convert_str_volume_to_obj(volume: str) -> Volumes:
    # generated by gpt4o. Let's hope it works
    short_syntax_regex = re.compile(
        r"^(?P<source>[^:]+):(?P<target>[^:]+)(?::(?P<access_mode>[^:]+))?$"
    )

    match = short_syntax_regex.match(volume)
    if match:
        source = match.group("source")
        target = match.group("target")
        access_mode = match.group("access_mode")

        return Volumes(
            type="bind",
            source=source,
            target=target,
            read_only=access_mode == "ro" if access_mode else None,
        )
    else:
        raise ValueError(f"Invalid volume format: {volume}")


class ComposeFile(ComposeSpecification):
    @classmethod
    def from_dict(cls, compose_dict: dict[Any, Any]) -> "ComposeFile":
        return cls(**compose_dict)

    @classmethod
    def from_file(cls, file_path: str | Path) -> "ComposeFile":
        with open(file_path, "r", encoding="utf8") as file:
            return cls.from_dict(yaml.load(file, Loader=yaml.CLoader))

    @classmethod
    async def async_from_file(cls, file_path: str | Path) -> "ComposeFile":
        async with aiofiles.open(file_path, "r", encoding="utf8") as file:
            return cls.from_dict(yaml.load(await file.read(), Loader=yaml.CLoader))

    def to_dict(self) -> dict[Any, Any]:
        return self.model_dump(exclude_none=True)

    def to_file(self, file_path: str | Path) -> None:
        with open(file_path, "w", encoding="utf8") as file:
            yaml.dump(self.to_dict(), stream=file, Dumper=yaml.CDumper, sort_keys=False)

    async def async_to_file(self, file_path: str | Path) -> None:
        async with aiofiles.open(file_path, "w", encoding="utf8") as file:
            await file.write(
                yaml.dump(self.to_dict(), Dumper=yaml.CDumper, sort_keys=False)
            )

    @model_validator(mode="after")
    def expand_services(self) -> Self:
        """
        compose_models.py is generated, so we shouldn't add validation logic there.
        """
        if self.services is None:
            return self
        for service_def in self.services.values():
            if service_def.ports is not None:
                new_ports = list[Ports]()
                for port in service_def.ports:
                    if not isinstance(port, Ports):
                        new_ports.append(convert_str_port_to_obj(port))
                    else:
                        new_ports.append(port)
                service_def.ports = new_ports

            if service_def.environment is not None:
                environment = service_def.environment
                if isinstance(environment, list):
                    new_env = dict[str, str]()
                    for e in environment:
                        assert isinstance(e, str)
                        assert "=" in e
                        key, value = e.split("=", 1)
                        new_env[key] = value
                    service_def.environment = new_env

            if service_def.volumes is not None:
                new_volumes = list[Volumes]()
                for volume in service_def.volumes:
                    if not isinstance(volume, Volumes):
                        new_volumes.append(convert_str_volume_to_obj(volume))
                    else:
                        new_volumes.append(volume)
                service_def.volumes = new_volumes

        return self
