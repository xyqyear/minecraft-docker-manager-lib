import re
from pathlib import Path
from typing import Annotated, Any, Mapping, Self, Sequence

import aiofiles
import yaml
from pydantic import BaseModel, Field, model_validator


class Ports(BaseModel):
    host_ip: str | None = None
    published: str | int | None = None
    target: int | str | None = None
    protocol: str | None = None


class Volumes(BaseModel):
    type: str
    source: str | None = None
    target: str | None = None
    read_only: bool | str | None = None


class Build(BaseModel):
    context: str | None = None
    dockerfile: str | None = None


class Service(BaseModel):
    container_name: str | None = None
    image: str | None = None
    build: str | Build | None = None
    ports: Sequence[float | str | Ports] | None = None
    volumes: Sequence[str | Volumes] | None = None
    environment: Mapping[str, str | float | bool | None] | Sequence[str] | None = None
    env_file: str | Sequence[str] | None = None
    stdin_open: bool | str | None = None
    tty: bool | str | None = None
    restart: str | None = None
    command: str | Sequence[str] | None = None
    network_mode: str | None = None
    privileged: bool | str | None = None
    user: str | None = None
    hostname: str | None = None
    mac_address: str | None = None
    extra_hosts: Mapping[str, str | Sequence[Any]] | Sequence[str] | None = None
    depends_on: Sequence[str] | None = None
    links: Sequence[str] | None = None
    expose: Sequence[str | float] | None = None
    cap_add: Sequence[str] | None = None
    group_add: Sequence[str | float] | None = None
    devices: Sequence[str] | None = None
    pid: str | None = None
    healthcheck: Mapping[str, Any] | None = None


class ComposeSpecification(BaseModel):
    version: Annotated[str | None, Field(None, description='declared for backward compatibility, ignored.')] = None
    name: Annotated[str | None, Field(
        None,
        description='define the Compose project name, until user defines one explicitly.',
    )] = None
    services: Mapping[str, Service] | None = None
    volumes: Mapping[str, Any] | None = None


def convert_str_port_to_obj(port: float | str) -> Ports:
    if not isinstance(port, str):
        port = str(int(port))

    # generated by gpt4o. Let's hope it works
    short_syntax_regex = re.compile(
        r"^(?:(?P<host_ip>\d{1,3}(?:\.\d{1,3}){3}):)?"
        r"(?P<host_port>\d+(-\d+)?):(?P<container_port>\d+(-\d+)?)(?:/(?P<protocol>\w+))?$|"
        r"^(?P<container_only_port>\d+(-\d+)?)(?:/(?P<container_only_protocol>\w+))?$"
    )

    match = short_syntax_regex.match(port)
    if match:
        host_ip = match.group("host_ip")
        host_port = match.group("host_port")
        container_port = match.group("container_port")
        protocol = match.group("protocol")

        if container_port is None:
            container_port = match.group("container_only_port")
            protocol = match.group("container_only_protocol")

        return Ports(
            host_ip=host_ip,
            published=host_port,
            target=container_port,
            protocol=protocol,
        )
    else:
        raise ValueError(f"Invalid port format: {port}")


def convert_str_volume_to_obj(volume: str) -> Volumes:
    # generated by gpt4o. Let's hope it works
    short_syntax_regex = re.compile(
        r"^(?P<source>[^:]+):(?P<target>[^:]+)(?::(?P<access_mode>[^:]+))?$"
    )

    match = short_syntax_regex.match(volume)
    if match:
        source = match.group("source")
        target = match.group("target")
        access_mode = match.group("access_mode")

        return Volumes(
            type="bind",
            source=source,
            target=target,
            read_only=access_mode == "ro" if access_mode else None,
        )
    else:
        raise ValueError(f"Invalid volume format: {volume}")


class ComposeFile(ComposeSpecification):
    @classmethod
    def from_dict(cls, compose_dict: dict[Any, Any]) -> "ComposeFile":
        return cls(**compose_dict)

    @classmethod
    def from_file(cls, file_path: str | Path) -> "ComposeFile":
        with open(file_path, "r", encoding="utf8") as file:
            return cls.from_dict(yaml.load(file, Loader=yaml.CLoader))

    @classmethod
    async def async_from_file(cls, file_path: str | Path) -> "ComposeFile":
        async with aiofiles.open(file_path, "r", encoding="utf8") as file:
            return cls.from_dict(yaml.load(await file.read(), Loader=yaml.CLoader))

    def to_dict(self) -> dict[Any, Any]:
        return self.model_dump(exclude_none=True)

    def to_file(self, file_path: str | Path) -> None:
        with open(file_path, "w", encoding="utf8") as file:
            yaml.dump(self.to_dict(), stream=file, Dumper=yaml.CDumper, sort_keys=False)

    async def async_to_file(self, file_path: str | Path) -> None:
        async with aiofiles.open(file_path, "w", encoding="utf8") as file:
            await file.write(
                yaml.dump(self.to_dict(), Dumper=yaml.CDumper, sort_keys=False)
            )

    @model_validator(mode="after")
    def expand_services(self) -> Self:
        """
        compose_models.py is generated, so we shouldn't add validation logic there.
        """
        if self.services is None:
            return self
        for service_def in self.services.values():
            if service_def.ports is not None:
                new_ports = list[Ports]()
                for port in service_def.ports:
                    if not isinstance(port, Ports):
                        new_ports.append(convert_str_port_to_obj(port))
                    else:
                        new_ports.append(port)
                service_def.ports = new_ports

            if service_def.environment is not None:
                environment = service_def.environment
                if isinstance(environment, list):
                    new_env = dict[str, str]()
                    for e in environment:
                        assert isinstance(e, str)
                        assert "=" in e
                        key, value = e.split("=", 1)
                        new_env[key] = value
                    service_def.environment = new_env

            if service_def.volumes is not None:
                new_volumes = list[Volumes]()
                for volume in service_def.volumes:
                    if not isinstance(volume, Volumes):
                        new_volumes.append(convert_str_volume_to_obj(volume))
                    else:
                        new_volumes.append(volume)
                service_def.volumes = new_volumes

        return self
